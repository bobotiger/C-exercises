# 填空题
## 1
- 写出以下程序段的输出结果：输入 4，则输出 ______；输入 5，则输出 ______；输入 12，则输出 ______；输入 -5，则输出 ______。
```c
int i, n = 5, x, a[10] = {1, 3, 5, 7, 9};
scanf("%d", &x);
for(i = n-1; i >= 0; i--)
    if(x < a[i]) 
        a[i + 1] = a[i];
    else 
        break;
a[i+1] = x;
n++;
printf("%d", i+1);
```
### 解析
```
--------------------------------
输入 x 的值
逆向循环遍历数组a
  如果 a[i] > x, a[i+1]=a[i]
  否则 终止循环
a[i+1] = x
n++
输出 i+1
--------------------------------
数组a的元素是升序，并逆向遍历
    只要 x 大于等于 当前数组元素 a[i], 循环退出，i的值保持，程序直接输出 i+1
换句话说，就是本程序的输出，其实就跟循环结束时i的值有关系；
-------------------------------
输入4时，a[1] < 4, 循环退出，输出 1+1 = 2
输入5时，a[2] = 5，循环退出，输出 2+1 = 3
输入12时，a[4] < 12, 循环退出，输出 4+1 = 5
输入-5时，所有数组元素都大于x，因此直到i=-1时，循环退出，输出 -1+1 = 0
```

## 2
- 求数组中相邻元素之和。将数组 x 中相邻两个元素的和依次存放到数组 a 中。请填空。
```c
int i, a[9], x[10];
for(i = 0; i < 10; i++)
    scanf("%d", &x[i]);

for(_______; i < 10; i++)
    a[i - 1] = _______ + x[i];
```
### 解析
```
for循环的目的，就是将数组x中相邻的元素累加，保存在数组a中
循环体：a[i-1] = _____ + x[i]，该空大概率应该是 x[i-1] 
循环初始状态：即i的初始值应该是从几开始，由于循环体中存在i-1的下标，大概率i=1，而不是0
```
```c
int i, a[9], x[10];
for(i = 0; i < 10; i++)
    scanf("%d", &x[i]);

for(i=1; i < 10; i++)
    a[i-1] = x[i-1] + x[i];
```
```
循环迭代过程推演：
i=1: a[0] = x[0] + x[1];
i=2: a[1] = x[1] + x[2];
i=3: a[2] = x[2] + x[3];
...
i=9: a[8] = x[8] + x[9];
现在最后能够得到题意要求的执行结果
```

## 3
- 简化的插入法排序。将一个给定的整数 x 插到已按升序排列的整型数组 a 中，使数组仍按升序排列。假定变量都已确定并赋值，请填空。
```c
for(i = 0; i < n; i++)
    if(_______)
        break;

for(_______)
    a[j + 1] = a[j];

_______;
n++;
```
### 解析
#### 插入排序的思想
```
1. 初始状态: 把数组的第一个元素视为已排序区间，其余元素为未排序区间。
2. 依次处理未排序元素: 从第二个元素开始，拿当前元素与已排序区间中的元素比较。
3. 找到插入位置: 如果当前元素比已排序区间的某元素小，就将该元素和之后的部分依次右移，为它腾出位置。
4. 插入到合适位置: 将当前元素插入腾出的位置中，这样已排序区间长度增加 1。
重复步骤 2~4 直到所有元素都被处理完成，整个数组有序。

需排序数组：[ 5, 3, 4, 1, 2 ]
初始状态：  已排序区间: [5] | 未排序区间: [3, 4, 1, 2]

第1次插入：
[5]↑  →  3 < 5，移动5 右移
[ _, 5, 4, 1, 2 ]
插入 3：
[3, 5] | [4, 1, 2]

第2次插入：
[3, 5]↑ →  4 < 5，移动5 右移
插入 4：
[3, 4, 5] | [1, 2]

第3次插入：
[3, 4, 5]↑ →  1 < 5，移动 5；  
              1 < 4，移动 4；  
              1 < 3，移动 3  
插入 1：
[1, 3, 4, 5] | [2]


第4次插入：
[1, 3, 4, 5]↑ →  2 < 5，移动 5
                 2 < 4，移动 4；  
                 2 < 3，移动 3 
插入 2：
[1, 2, 3, 4, 5] | []

```
#### 本题思路
```
由于数组元素已升序排列
    首先，确定 整数x 需要插入 数组a 的位置i，即第一个大于 x 的 a[i]
    然后，将 a[i] ~ a[n-1] 的元素依次向后移动一个位置
    最后，a[i] = x
```
```c
for(i = 0; i < n; i++)
    if(a[i]>x)
        break;

for(j=i; j<n; j++)
    a[j + 1] = a[j];

a[i] = x;
n++;
```

## 4
- 输入8，以下程序段的输出结果为 ______，输入 5，输出结果为 ______。
```c
int i, max_sum, n, this_sum, 
a[] = {-1, 3, -2, 4, -6, 1, 6, -1};

scanf("%d", &n);
max_sum = this_sum = 0;

for(i = 0; i < n; i++){
    this_sum += a[i];
    if(this_sum > max_sum) 
        max_sum = this_sum;
    else if(this_sum < 0) 
        this_sum = 0;
}

printf("%d\n", max_sum);
```
### 解析
```
本程序段最终要输出的是 max_sum 的值
    程序中有两处语句对 max_sum 进行了赋值
        max_sum = this_sum = 0; (这句初始化max_sum为0)

        if(this_sum > max_sum) 
            max_sum = this_sum;
        这句可以看出，在this_sum 大于 max_sum 时，max_sum的值就是this_sum的值

    而this_sum的值会因为循环累加a[i]的值而发生变换；
    如果this_sum值为负时，this_sum = 0
        
    循环次数为8时：
        数组a的元素值为：            {-1, 3, -2, 4, -6, 1, 6, -1}
        循环迭代过程中 this_sum ：     0, 3,  1, 5,  0, 1, 7,  6
        循环迭代过程中 max_sum  :      0, 3,  3, 5,  5, 5, 7,  7 
    循环次数为5时：
        数组a的元素值为：            {-1, 3, -2, 4, -6, 1, 6, -1}
        循环迭代过程中 this_sum ：     0, 3,  1, 5,  0
        循环迭代过程中 max_sum  :      0, 3,  3, 5,  5
```
#### 验证程序
```c
#include <stdio.h>
int main()
{
    int i, max_sum, n, this_sum, 
    a[] = {-1, 3, -2, 4, -6, 1, 6, -1};

    scanf("%d", &n);
    max_sum = this_sum = 0;

    printf("%6s%9s%9s\n","a[i]","this_sum","max_sum");
    for(i = 0; i < n; i++){
        this_sum += a[i];
        if(this_sum > max_sum) 
            max_sum = this_sum;
        else if(this_sum < 0) 
            this_sum = 0;

        printf("%6d%9d%9d\n",a[i], this_sum, max_sum);
    }

    printf("%d\n", max_sum);
        
    return 0;
}
```
- 验证程序执行结果
```
8
  a[i] this_sum  max_sum
    -1        0        0
     3        3        3
    -2        1        3
     4        5        5
    -6        0        5
     1        1        5
     6        7        7
    -1        6        7
7

5
  a[i] this_sum  max_sum
    -1        0        0
     3        3        3
    -2        1        3
     4        5        5
    -6        0        5
5
```

## 5 
- 输入1 2 3 4 5 6，则程序段 A 的输出结果是 ______，程序段 B 的输出结果是 ______。

- 程序段A
```c
int i, j, table[3][2];	
for(i = 0; i < 3; i++)	
    for(j = 0; j < 2; j++)	
        scanf("%d", &table[i][j]);	
for(i = 0; i < 3; i++)	
    for(j = 0; j < 2; j++)	
        printf("%d#", table[i][j]);	
``` 
- 程序段B
```c
int i, j, table[3][2];
for(j = 0; j < 2; j++)
    for(i = 0; i < 3; i++)
        scanf("%d", &table[i][j]);
for(i = 0; i < 3; i++)
    for(j = 0; j < 2; j++)
        printf("%d#", table[i][j]);
```
### 解析
- 程序段A
```
数组table[3][2]: 是3行 2列
第一个双层嵌套循环，外层循环遍历行，内层循环遍历列，即按行输入数据到数组
输入1 2 3 4 5 6
table   [1 2]
        [3 4]
        [5 6]
第二个双层嵌套循环，外层循环遍历行，内层循环遍历列，即按行输出数据到数组
输出 1#2#3#4#5#6#
```
- 程序段B
```
数组table[3][2]: 是3行 2列
第一个双层嵌套循环，外层循环遍历列，内层循环遍历行，即按列输入数据到数组
输入1 2 3 4 5 6
table   [1 4]
        [2 5]
        [3 6]
第二个双层嵌套循环，外层循环遍历行，内层循环遍历列，即按行输出数据到数组
输出 1#4#2#5#3#6#
```

## 6
- 判断二维数组是否对称。检查二维数组 a 是否对称，即满足所有 i、j 都有 a[i][j] 和 a[j][i] 的值相等。假定变量都已正确定义并赋值，请填空。

```c
found = 1;
for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
        if(_______){
            _______;
            break;
        }
    }
    if(_______) break;
}

if(found != 0) 
    printf("该二维数组对称\n");
else 
    printf("该二维数组不对称\n");
```
### 解析
```
程序段现有逻辑，found初始值为1，通过最后的if...else语句可知
    found为1时：表示二维数组对称
    found为0时：表示二维数组不对称

因此前面的双层嵌套循环
    只要存在 a[i][j] != a[j][i], 则found=0，并结束继续判断
    如果在内层循环调用break，只会终止内曾循环，然而外层循环此时也应终止
        因此需根据found是否为0，来决定是继续执行外层循环，还是调用break终止外层循环
```
```c
found = 1;
for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
        if(a[i][j] != a[j][i]){
            found=0;
            break;
        }
    }
    if(found==0) break;
}

if(found != 0) 
    printf("该二维数组对称\n");
else 
    printf("该二维数组不对称\n");
```

## 7
- 字符串复制。将字符串 str1 的内容复制到字符串 str2。假定变量都已正确定义并赋值，请填空。
```c
i = 0;
while(_______){
    _______;
    i++;
}
_______;
```
### 解析
- **字符串**是一个特殊的**一维字符数组**，之所以特殊是在最后一个字符之后包含一个**字符串终止符**:`'\0'`
- 循环遍历字符串中的字符时，可以通过判断字符是否为`'\0'`，来决定是否已经遍历完毕；
```c
i = 0;
while(str1[i]!='\0'){
    str2[i] = str1[i];
    i++;
}
str2[i]='\0';
```
## 8
- 删除字符串中的空格。将字符串 str 中的所有空格都删除。假定变量都已正确定义并赋值，请填空。
```c
i = j = 0;
while(_______){
    if(_______){
       str[j] = str[i];
       _______;
    }
    i++;
}
_______;
```
### 解析
```
初始字符串："I love C language!"
删除空格后："IloveClanguage!"

思路：
    遍历整个字符串str
        如果str[i] != ' '
            保留该字符：str[j]=str[i]; j++;
        否则直接跳过
        i++;
    最后在当前字符串的最后字符后加上终止符'\0'：str[j]='\0';      
```
```c
i = j = 0;
while(str[i] != '\0'){
    if(str[i] != ' '){
       str[j] = str[i];
       j++;
    }
    i++;
}
str[j]='\0';
```