# 数据
## 常量
- **常量**是你对C语言表达："我心里有个数据，想要告诉你它是什么"的一种方式
- 在C语言程序中，任何数据都是具有类型的；
  - 任何数据在计算机中都是二进制形式存放的，且连续存放在一个一维线性空间中，因此要准确获取其中的一个数据，势必需要知道该数据的**存放首地址**，以及**存储长度**；
  - 之所以需要划分**类型**，一方面是因为C语言需要知道要用多少字节(*8个二进制数位组成*)存放该类型数据；另一方面，整型、双精度浮点、单精度浮点在**计算机内的存储方式**也是不一样的；
### 整数
- 按不同进制表示：
  - 十进制：100
  - 八进制：0100
  - 十六进制：0x100
- c语言默认整数常量为int类型，如果你想让C语言将整型常量视为long类型，可以在数字末尾加上`l/L`
  - 十进制：100l
  - 八进制：0100L
  - 十六进制：0x100L
### 实数
- 小数表达方式
  - 1234.0
  - 0.01234
- 科学计数表达方式
  - 1.234e3
  - 1.234E-2
- c语言默认实数常量为double类型，如果你想让C语言将实数常量视为float类型，可以在数字末尾加上`f/F`
### 字符
- 字符类型是初学者非常容易误解的一个概念，认为计算机中字符就是他们看到的那个字面符号，其实并非如此，实际情况是：
  - 在C程序中表示的字符本质是一个编码，如运行时需要显示该字符的字面样子，需要：
    - 通过该编码去查询一张系统内建的符号表，找到对应字符的点阵序列；
    - 由计算机的显示系统以及计算机硬件(显卡，显示器等)一起将该字符点阵通过电信号打印到屏幕上；
    - 最后光线反射进入你的眼中，你最终看到该符号的图形形象；
- C语言中字符常量，通常以单引号`''`包含单个字符符号，如：`'a'`,`'A'`;
- 直接使用字符的编码也能在C语言中表示字符常量，之所以可以如此，是因为我们可以通过某种方式告知C语言，让它如何处理这个整数，例如通过 `"%c"` 告诉C我想输出或接收输入一个字符数据；
  - 97
  - 0141
  - 0x61
- 转义序列，在C语言中通过`'\'`这个符号来表示转义序列开始，转义序列最终被解释为一个字符；
  - `'\141'`、`'\x61'`  这非常适合表达那些无法通过键盘直接键入的字符
  - `'\n'`,`'\r'`,`'\t'`,`'\\'`  将一个字面义字符，转义为特殊含义字符；或将一个特殊含义字符转义为其字面意义；
### 字符串
- 字符串本质上就是由多个字符组成的序列，在C程序中，可以通过双引号`""`将多个连续字符的包括起来来表达；
  - `"Hello World!"`
- 字符串在C语言中实际上是通过一个一维字符数组进行存储，其特殊的一点在于，C语言会自动在字符串的最后一个有效字符后添加一个字符串终止符`'\0'`(其ASCII码值即为0)；
- 因此你在使用字符串对一个一维字符数组进行初始化时，需确保字符数组要有空间要能存放字符串最后的那个终止符`'\0'`，你可以
  - `char str[] = "Hello World!";`
  - `char str[13] = "Hello World!";`
  - `char str[100] = "Hello World!";`

## 变量
- **变量**是你向C语言申请一个存放**特定类型**数据的**存储空间**
  - 使用变量前，必须先定义；
    - `int a;`
  - 变量定义后，其对应的存储空间中的值是不确定了，因此在使用变量之前需要为其赋值；
    - `int a = 10;`  // 定义时，同时为其赋值，这被称为变量的初始化
    - `int a; a=10;` // 定义后，然后通过赋值语句进行赋值，这和初始化的行为虽相似，但并不是所谓初始化；
  - 变量必定包含如下几个特性：
    - **类型**：决定该变量能够存放什么数据，占用多少字节
    - **名字**：便于通过该名字索引到对应的存储空间地址；这比让用户记住一串无规律的数字表示的内存地址要方便很多；
    - **值**：即变量对应存储空间中存放的数据，该值在程序执行过程中是可以改变的；改变变量值方法主要有：
      - 赋值语句：`a = 100；`
      - 调用输入函数：`scanf("%d",&a);`

## 数组
- **数组**是你向C语言申请一批存放**特定类型**数据的**存储空间**
  - 数组申请的存储空间所能存放的数据类型都是一样的，即每个存储空间大小一致；
  - 数组申请的这些大小一致的存储空间，在物理上是连续的线性空间；
- 使用数组前，必须先定义
  - `int a[100];` // 定义一个能够存放100个int类型数据的连续存储空间，其首个存储空间的地址计为a，也就是所谓的**数组名**
  - 其中方括号`[]`中的数字描述数组长度，即申请多少个int类型的存储空间；该数字必须是一个**整型常量**
- 数组初始化
  - `int a[100] = {10};` // 将第一个元素初始化为10，其他元素被填充0
  - `int a[] = {1,2,3};` // 在进行数组初始化时，可以不明确给定数组长度，而由初始化数据的个数决定分别的存储空间数量；
- 元素引用
  - 数组可以看作将多个变量的线性序列，它们可以通过**数组名**(*首地址*)+**下标**(*相对首地址的偏移量*)来进行定位
  - `int temp = a[1];` // 取出数组a的下标为1的元素值，将其赋值给temp变量
  - `a[0] = a[1];` // 取出数组a的下标为1的元素值，将其赋值给数组a的小标为0的元素存储空间
- 数组名可视为数组的首个元素的存储地址，因此并不能寄希望通过数组名来操作整个数组；而因该通过循环配合数组下标来遍历所有数组元素的方式来操作整个数组
  - 遍历写数组
  ```c
  #define LEN 10;
  int a[LEN];
  for(int i=0; i<LEN; i++){
    scanf("%d", &a[i]);
  }
  ```
  - 遍历读数组
  ```c
  for(int i=0; i<LEN; i++){
    if(i>0) printf(" ");
    printf("%d", a[i]);
  }
  printf("\n");
  ```
- 二维数组定义及初始化
```c
#define ROW 3
#define COL 3
int a[ROW][COL] = {1,2,3,4,5,6,7,8};
/**
    1 2 3
    4 5 6
    7 8 0
*/
```
```c
#define ROW 3
#define COL 3
int a[ROW][COL] = {{1,2},{3,4,5},{6,7,8}};
/**
    1 2 0
    3 4 5
    6 7 8
*/
```
```c
#define ROW 3
#define COL 3
int a[][COL] = {1,2,3,4,5,6,7,8,9,10};
/**
    1 2 3
    4 5 6
    7 8 9
    10 0 0
*/
```
```c
#define ROW 3
#define COL 3
int a[][COL] = {{1,2},{3,4},{5,6},{7},8,9,10};
/**
    1 2 0
    3 4 0
    5 6 0
    7 0 0
    8 9 10
*/
```
- 二维数组元素引用
  - 二维数组可以看作多个一维数组的堆叠
  ```
  a --> a[0] --> a[0][0] ...
        a[1] --> a[1][0] ...
        a[2] --> a[2][0] ...
        ...
        a[ROW-1] --> a[ROW-1][0] ...
  ```
  二维数组名可以看作指向一个存放多个一维数组首地址的数组的首元素地址，即
  ```
  a --> |a[0]|a[1]|a[2]|a[3]|...|a[ROW-1]|
  ```
  而该一维数组的每个元素则可以视为一个一维数组名，即首元素地址，例如
  ```
  a[0] --> |a[0][0]|a[0][1]|a[0][2]|a[0][3]|...|a[0][COL-1]|
  a[1] --> |a[1][0]|a[1][1]|a[1][2]|a[1][3]|...|a[1][COL-1]|
  a[2] --> |a[2][0]|a[2][1]|a[2][2]|a[2][3]|...|a[2][COL-1]|
  ...
  ```
- 遍历写二维数组
```c
#define ROW 3;
#define COL 3;
int a[ROW][COL];
for(int i=0; i<ROW; i++){
    for(int j=0; j<COL; j++){
        scanf("%d", &a[i][j]);
    }
}
```
- 遍历读二维数组
```c
for(int i=0; i<ROW; i++){
    for(int j=0; j<COL; j++){
        if(j>0) printf(" ");
        printf("%d", a[i][j]);
    }
    printf("\n");
}
```

## 指针
- 计算机系统使用**内存**来存放数据，大部分计算机系统将**内存**以**字节**(*byte,占8位二进制数位*)为单位进行分配
- 内存中的每个字节都有唯一的地址，该地址从0开始编制，例如：32位地址的地址范围为：0 ~ $2^{32}-1$ ；因此
  - 32位系统，需要使用32位二进制数表示内存地址，即需要4个字节
  - 64位系统，需要使用64位二进制数表示内存地址，即需要8个字节
- 虽然内存地址以整数表示，但其取值范围和整数的取值范围不同，因此不适合使用普通的整型变量进行保存，而要使用特殊的指针变量进行存储；
### 指针变量定义
- `int *p;`  // 在定义指针变量时，变量名前必须使用**指针声明符**：`*`
### 指针变量初始化
- 指针变量定义时，和普通变量一样，其内存放的数据是随机的，不确定的，在使用之前必须保证其内部存放的地址指向合法的存储空间
  - 初始化时，如果还不确定要存放什么地址，可以将其初始化为NULL，避免误用，而访问了不该访问的位置；
    ```c
    int *p = NULL;
    ```
  - 初始化时，可以使用取地址运算符`&`，将已存在的变量地址作为其初始地址；使其指向该变量的存储空间；
  ```c
  int a = 10;
  int *p = &a;
  ```
  - 初始化时，可以使用动态内存分配函数，向系统申请一段内存空间，并将其返回的地址作为其初始地址；如果内存分配失败，则会返回NULL
  ```c
  #include <stdlib.h>
  int *p = (int *)malloc(sizeof(int));
  // 使用完毕后，记得释放内存
  free(p);
  // 内存虽然释放了，但是指针变量p中依然存放着已经释放的内存空间地址，如果之后继续访问该指针变量，就会带来未知问题
  // 因此建议将指针变量赋值为NULL
  p=NULL;
  ```
### 指针的运算
- 指针形式上就是一个整数，因此可以进行整数的相关运算，但是需要注意：
  - 可以在指针上加上一个整数(作为偏移量)，来表示相对于该指针偏移到指定偏移量的位置，常见数组元素的引用
  ```c
  int a[10] = {1,2,3,4,5,6};
  printf("%d\n", *(a+1)); // 相当于对相对于数组首元素地址偏移1个单位的地址进行解引用操作，即获取元素a[1]的值
  int *p = a; // 指针p指向数组a的首元素地址
  printf("%d\n", *(p+2)); // 对相对指针p偏移2个单位的地址进行解引用，即获取数组元素a[2]的值
  ```
  - 可以将**两个类型相同的指针做减法运算**， 即计算这两个地址之间的偏移量有多少
  ```c
  int a[10];
  printf("%d\n", &a[9]-a);  // 输出结果为9，即表示数组下标为9的元素地址与数组首元素地址的偏移量有9个单位存储空间；
  ```
  - 不可以将**两个类型相同的指针做加法运算**，因为两个地址做加法得到的结果毫无意义，因此C语言不允许对两个地址做加法运算；
  - 可以使用取地址运算符`&`：获取变量的存储空间地址，即变量对应的内存空间的地址
  - 可以使用解引用运算符`*`：放在赋值表达式左侧时，作为内存空间使用；放在赋值表达式右侧时，取出内存空间存放的值使用
  ```c
  int a = 10;
  int *p = &a;  // p 指向 变量 a
  *p = 20;      // *p 相当于 变量a ，即 等价于  a = 20；
  *p = *&a;     // * 和 & 是单元运算符，它们优先级相同，结合性从右到左运算，因此先获取变量a的地址，然后再对该地址解引用，即获取变量a的值
  int *q = &*p;  // 先对p进行解引用获取指向的内存空间，然后再获取该内存空间的地址，因此q此时也指向a；
  printf("%p: %d\n%p: %d\n%p: %d\n", &a,a,p,*p , q,*q);
  // 输出结果可能为
  /**
    00000031B3FFFBDC: 20
    00000031B3FFFBDC: 20
    00000031B3FFFBDC: 20
  */
  ```

## 结构类型
- 结构与数组一样也是一种复合数据类型，可以将多个变量组合在一起，不同的是，结构类型中的多个变量可以是不同类型
### 结构类型定义及变量定义
- 方法1: 结构类型: `struct student`
```c
struct student{
    char no[16];
    char name[16];
    double math;
    double english;
    double computer;
};
```
- 定义变量
```c
struct student stu1;
```
- 方法2：结构类型：`Student`
```c
typedef struct{
    char no[16];
    char name[16];
    double math;
    double english;
    double computer;
} Student;
```
- 定义变量
```c
Student stu2;
```
- 方法3：结构类型：`struct Node` 或 `Node`
- 这种方法的好处是，在不需要自引用时，可以使用简洁的类型名`Node`定义变量；而在需要自引用时，则可使用`struct Node`类型(所谓自引用，就是需将在结构的成员定义为该结构类型)
```c
typedef struct Node{
    int data;
    struct Node *next;
} Node;
```
- 定义变量
```c
// 既可以如下定义变量
struct Node node1;
// 也可以如下定义变量
Node node2;
```
#### 结构的嵌套定义
- 结构成员类型是另外一个结构类型(需要事先定义好)
```c
struct address{
    char city[60];
    char street[100];
    char zip[10];
};

struct student{
    char no[16];
    char name[16];
    double math;
    double english;
    double computer;
    struct address addr;
};
```
### 结构对象的成员引用
- 对于结构类型对象的成员引用可以使用**成员访问运算符**`.`
```c
#include <string.h>
Student stu1;
strcpy(stu1.name, "Tom")
printf("%s\n", stu1.name);
```
- 对嵌套定义的结构类型的成员引用
```c
#include <string.h>
struct student stu1;
strcpy(stu1.addr.zip, "12345678");
printf("%s\n", stu1.addr.zip);
```
- 通过指向结构类型变量的指针引用结构成员
```c
#include <string.h>
struct student stu1;
struct student *stuptr = &stu1;
strcpy(stuptr->addr.zip, "12345678");
printf("%s\n", stuptr->addr.zip);
return 0;
```