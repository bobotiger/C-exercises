# 练习题

## 1
- 下列语句定义 px 为指向 int 类型变量 x 的指针，正确的是_______。

```
A. int x, *px = x;
B. int x, *px = &x;
C. int *px = &x, x;
D. int x, px = *x;
```
### 解析
- 定义指针变量时，必须在变量名前使用**指针声明符**：`*`，因此排除选项D
- 指针变量中存放的是内存地址，因此排除选项A
- 在同一行定义多个变量时，使用逗号运算符分隔，其从左向右结合，因此先执行左侧的定义，由于向指针变量赋值的地址必须合法，即该地址需指向一个有效的内存空间，如果x变量在指针变量之后定义，在此之前使用&x就无法获得有效地址，因此排除选项C


## 2
- 以下选项中，对基本类型相同的指针变量不能进行运算的运算符是_______。
```
A. =
B. ==
C. +
D. -
```
### 解析
- 相同类型的指针变量可进行**赋值运算**;
  ```c
    int *p,*q,x; 
    p =& x; 
    q = p;
  ```
- 相同类型的指针变量间可以进行**判等运算**； 
  ```c
  if(p == q){} // 判断两个指针是否指向同一地址
  ```
- 相同类型的指针变量间不能进行**加法运算**; 因为两个地址相加没有任何意义；
  - 但指针变量可以与整数间进行**加法运算**
  ```c
  int a[10]; 
  int *p = a; 
  p = p + 3; // 这时p指向a[3]
  ```
- 相同类型的指针变量间可以进行**减法运算**；用于表示两个指针之间元素的距离
  ```c
  int a[10];
  int *p = &a[2]; 
  int *q = &a[7]; 
  int d = q - p; // 得到两个元素a[7]与a[2]之间的距离5
  ```

## 3
- 下列程序的输出结果是_______。
```c
void f(int *p)
{
    *p = 5;
}

int main(void)
{
    int x = 10, *px = &x;
    f(px);
    printf("%d#", (*px)++);
    printf("%d\n", x);
    return 0;
}
```
```
A. 5#6
B. 6#6
C. 10#11
D. 11#11
```
### 解析
- 子函数`f()`接受一个指针变量，其目的就是在函数内部的修改能够影响函数外部的变量值；
- 在主函数`main()`中，通过`f(px)`调用，将`x`的地址传递给`f()`函数，`f()`函数将该地址指向的内存空间中存放`5`；
- 接下来的一个`printf()`，输出`px`指针指向内存空间的值，即`x`变量中的值，此时为`5`；然后再对x变量中的值进行加`1`操作
- 再次打印输出`x`变量的值，此时为`6`；

## 4
- 以下程序的输出结果是_______。
```c
void sub(int x, int y, int *z)
{
    *z = y - x;
}

int main(void)
{
    int a, b, c;
    sub(10, 5, &a);
    sub(7, a, &b);
    sub(a, b, &c);
    printf("%d,%d,%d\n", a, b, c);
    return 0;
}
```
```
A. 5, 2, 3
B. 5, -2, -7
C. -5, -12, -17
D. -5, -12, -7
```
### 解析
- 子函数`sub()`的功能，就是接受两个参数`x`和`y`，将`y-x`的差保存到`z`中指针指向的内存空间中；
- 在main()函数对sub()进行了3次调用
  - 第一次调用：在a中保存 5-10的差，即 a 中存放 -5；
  - 第二次调用：在b中保存 a-7的差，即 b 中存放 -12；
  - 第三次调用：在c中保存 b-a的差，即 c 中存放 -7；
- 则输出结果为-5，-12，-7 

## 5
- 若有以下定义，且 0 ≤ i < 10，则对数组元素的错误引用是_______。
```c
int i, a[]={0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, *p=a;
```
```
A. *(a+i)
B. a[p-a+i]
C. p+i
D. *(&a[i])
```
### 解析
- 数组`a`的长度由其初始化时给定的数据个数决定，即此时数组`a`的长度为`10`；
  - 题目中描述`i`在`[0,10)`区间中取值；可见i没有超出数组a的有效下标范围
  - 数组名可以当作地址使用，因此选项A `*(a+i)` 就相当于 `a[i]`
- 指针变量`p`指向数组`a`的首元素；
  - 选项B `a[p-a+i]`，由于p和a指向同一个空间，因此进行减法运算后得0，因此就相当于`a[i]`
  - 选项C `p+i`，这仅是计算了一个地址，并没有对该地址解引用，无法得到该地址指向的内存空间所存放的值
- 选项D `*(&a[i])`, 由于`*` 和 `&`的结合性为从右向左结合，先取元素`a[i]`的地址，然后对该地址进行解引用，继而再次得到`a[i]`的值

## 6
- 下列程序段的输出结果是_______。
```c
int a[10]={0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, *p=a+3;
printf("%d", * ++p);
```
```
A. 3
B. 4
C. a[4] 的地址
D. 非法
```
### 解析
- 指针变量`p` 指向 数组`a`的下标为`3`的元素，即 `a[3]`
- 要输出的表达式为 `* ++p`；
  - `*` 与 `++`的优先级相同，但是结合性是从右向左
    - 因此首先运算`++`，由于其在变量`p`的左侧，因此先进行加`1`操作，在取变量`p`的值
    - 此时指针变量`p`指向数组`a`的元素`a[4]`, 对指针p当前地址解引用，会得到元素`a[4]`的值

## 7
- 对于下面的程序段，叙述正确的是_______。
```c
char s[]="china", *p=s;
```
```
A. *p 与 s[0] 相等
B. 数组 s 中的内容和指针变量 p 中的内容相等
C. s 和 p 完全相同
D. 数组 s 的长度和 p 所指向的字符串长度相等
```
### 解析
- 字符数组`s`的长度，由初始化的字符串`"china"`长度决定，字符串最后会额外包含一个终止符`'\0'`，因此数组`s`的长度为`6`；
- 指针变量p指向字符数组的首字符；
  - 选项A *p解引用所指向的空间的值 即 s[0]
  - 选项B 数组s的内容是字符序列，指针变量p存放的是一个指向存放字符类型数据的存储空间地址
  - 选项C 数组名s是一个地址常量，无法通过赋值改变其地址；而指针变量p则可以通过赋值指向新的地址；
  - 选项D p指向数组s的首地址，数组s中存放一个字符串，因此指针p也指向同一个字符串；

## 8
- 下述程序段的运行结果是_______。
```c
char s[]="language", *p=s;
while( *p++!='u'){
    printf("%c", *p - 'a' + 'A');
}
```
```
A. LANGUAGE
B. ANGU
C. LANGU
D. LANG
```
### 解析
- 循环条件：`*p++!='u'`
  - `*p++`: 先对指针`p`进行**解引用**，然后再对指针`p`的地址进行加`1`操作
    - **注意**：这里有一个副作用，每次判断完当前字符后，指针p就指向下一个字符了
      - 例如：在判断首字符`'l'`后，进入循环体之前指针`p`已经指向下一个字符`'a'`了
  - 如果当前p指向的空间中存放的不是字符`'u'`，循环就继续
    - 即遍历字符串，直到碰到字符`'u'`时结束
- 循环体：输出 `*p - 'a' + 'A'`
  - 这明显是一个将小写英文字母转大写英文字母的表达式
- 最终输出结果为 `ANGU`

