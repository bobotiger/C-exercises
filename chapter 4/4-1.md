# 练习 4-1
- 在例 4-1 程序中，如果对 item 赋初值 0，运行结果是什么？为什么？如果将精度改为 10^-3，运行结果有变化吗？为什么？
## 例4-1
```c 
/* 用格雷戈里公式计算 π 的近似值，精度要求：最后一项的绝对值小于给定精度 eps */
#include <stdio.h>
#include <math.h>               /* 程序中调用绝对值函数 fabs()，需包含 math.h */
int main(void)
{
    int denominator, flag, i;
    double eps, item, pi;           /* pi 用于存放累加和 */
    printf("Enter eps:");           /* 提示输入精度 eps */
    scanf("%lf", &eps);

    /* 循环初始化 */
    i = 1;                          /* i 表示当前的项数 */
    flag = 1;                       /* flag 表示第 i 项的符号，初始为正 */
    denominator = 1;                /* denominator 表示第 i 项的分母，初始为 1 */
    item = 1.0;                     /* item 中存放第 i 项的值，初值 1x1 */
    pi = 0;                         /* 置累加和 pi 的初值为 0 */
    while (fabs(item) >= eps) {     /* 当 |item| >= eps 时，执行循环 */
        pi = pi + item;             /* 累加第 i 项的值 */
        i++;                        /* 项数增 1，为下一次循环做准备 */
        flag = -flag;               /* 改变符号，为下一次循环做准备 */
        denominator = denominator + 2; /* 分母递增 2，为下一次循环做准备 */
        item = flag * 1.0 / denominator; /* 计算第 i 项的值，为下一次循环做准备 */
    }

    pi = pi + item;                 /* 加上最后一项的值 */
    pi = pi * 4;                    /* 循环计算的结果是 pi/4 */
    printf("pi=%.4f\n", pi);
    printf("i=%d\n", i);            /* 此处 i 的值为最后一项的项数 */
    return 0;
}
```
### 执行结果
```
Enter eps:0.000001
pi=3.1416
i=500001
```
### 如果对item赋初值0，程序的执行结果
```
Enter eps:0.000001
pi=0.0000
i=1
```
- 由于item初值为0，首次循环判定时，循环条件就判定为假，循环直接退出

### 在输入eps的值为0.001时的程序执行结果
```
Enter eps:0.001
pi=3.1436
i=501
```
- eps值设置的较大，直接导致循环次数降低，从而导致累加的序列项数降低，使最终计算的圆周率精度降低
